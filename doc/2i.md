Secondary Indexes
=================

Secondary indexes are a set of conventions for updating an alternate
keyspace when values are put into the Datastore. This keyspace allows
for rapid search of computed binary or integer attributes of a value.

Datastore supports compound indexes in ascending or descending order.

This is done by carefully constructing a key that maintains lexical
order for binary and integer index properties.

The format of these keys is:

    /_i/<index name>/<index key>/<data key>

<index name> encodes the data type of the index along with a
developer-facing name. The format is
$name_$col1type_$col2type_... Column types can be "bin" or
"int". Prepend a dash for a descending index.

e.g. an index by event timestamp (integer, descending) and type
(binary, ascending):

    events_-int_bin

Or a single column index on user name (binary, ascending):

    usernames_bin

As an illustration, creating an index "name_bin" on a lowercased
"name" field of this JSON (as binary data):

Key -> Value

/person/0 -> {"name": "Alice", "age": 43, "desc": "description 0"}
/person/1 -> {"name": "Bob", "age": 35, "desc": "description 1"}
/person/2 -> {"name": "Carol", "age": 37, "desc": "description 2"}
/person/3 -> {"name": "Bob", "age": 37, "desc": "description 3"}

Inserting the above with indexed names yields this (index keys
simplified for readability):

/_i/name_bin/alice/person/0 -> /person/0
/_i/name_bin/bob/person/1   -> /person/1
/_i/name_bin/bob/person/3   -> /person/3
/_i/name_bin/carol/person/2 -> /person/2

An index on both name and age would look like this:

/_i/name_age_bin_int/alice/43/person/0 -> /person/0
/_i/name_age_bin_int/bob/35/person/1   -> /person/1
/_i/name_age_bin_int/bob/37/person/3   -> /person/3
/_i/name_age_bin_int/carol/37/person/2 -> /person/2

Index keys are encoded column by column to preserve byte-wise sort
order. We support two encodings, for binary and number values. We use
SQLite 4's key encoding, described here:
http://sqlite.org/src4/doc/trunk/www/key_encoding.wiki

Binary encoding
---------------

Binary values are split into seven-bit chunks. Each seven-bit chunk is
encoded as a byte with its high bit set. The encoded value is followed
by a null byte, ensuring that two keys sort properly when one is a
prefix of the other.

e.g.

    "foo" -> 0b01100110 0b01101111 0b01101111
               ^      ^         ^         ^
          -> 0b10110011 0b10011011 0b11101101 0b11110000 0b00000000
                ^          ^          ^          ^

Number encoding
---------------

Numbers are encoded using a variable-width encoding that preserves
sort order for integers and decimal values. This is a complex
encoding, but we're lifting it wholesale for future expandability.

This format is described in the SQLite documentation linked above, but
here are some specifics:

Single byte numbers:

0x06: NaN
0x07: -Inf
0x15: 0
0x23: Inf

All other numeric values are stored as a base-100 mantissa and an exponent.

To encode:

1) Eliminate the decimal point from the number and split it into
two-digit pairs based on its centimal digits. Pad the start and end
with an extra zero if there are an odd number of digits on that side
of the decimal.

e.g. 1.0        -> 01 00
     10.0       -> 10 00
     100.0      -> 01 00 00
     99.0001    -> 99 00 01
     99.00001   -> 99 00 00 10

2) Convert each pair to its byte value in hex. Decimal shown as double
dots for alignment.

     01 .. 00         -> 0x01 .. 0x00
     10 .. 00         -> 0x0a .. 0x00
     01 00 .. 00      -> 0x01 0x00 .. 0x00
     99 .. 00 01      -> 0x63 .. 0x00 0x01
     99 .. 00 00 10   -> 0x63 .. 0x00 0x00 0x0a

3) Assuming all digits of the above will appear to the right of the
decimal, determine the base-100 exponent for each:

     0x01 .. 0x00             -> 1
     0x0a .. 0x00             -> 1
     0x01 0x00 .. 0x00        -> 2
     0x63 .. 0x00 0x01        -> 1
     0x63 .. 0x00 0x00 0x0a   -> 1

4) Drop trailing zeros and take each exponent and mantissa:

     E=1 M=0x01
     E=1 M=0x0a
     E=2 M=0x01
     E=1 M=0x63 0x00 0x01
     E=1 M=0x63 0x00 0x00 0x0a

5) Encode E and M

Values are classified as large, medium, or small according to the
value of E:

Small:         E < 0
Medium:   0 <= E < 10
Large:   10 <= E

And then encoded bytewise as follows:

Negative values:
Large:  0x08    ~E ~M
Medium: 0x13-E     ~M
Small:  0x14    -E ~M

Zero:   0x15

Positive values:
Small:  0x16   ~-E  M
Medium: 0x17+E      M
Large:  0x22     E  M
